// Generated by CoffeeScript 1.6.2
var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

jQuery(function() {
  var Item, Items, PasteBinView, getJSON, items, modNameLookup, mods, pasteBinView, processedItems, _ref, _ref1, _ref2;

  Array.prototype.filter = function(func) {
    var x, _i, _len, _results;

    _results = [];
    for (_i = 0, _len = this.length; _i < _len; _i++) {
      x = this[_i];
      if (func(x)) {
        _results.push(x);
      }
    }
    return _results;
  };
  getJSON = function(url) {
    return $.getJSON("" + url + ".json");
  };
  items = {
    amulet: {},
    belt: {},
    ring: {},
    boot: {},
    chest: {},
    glove: {},
    helmet: {},
    shield: {},
    axe: {},
    bow: {},
    claw: {},
    dagger: {},
    mace: {},
    quiver: {},
    rapier: {},
    sceptre: {},
    staff: {},
    sword: {},
    wand: {}
  };
  window.items = items = {};
  modNameLookup = {};
  mods = {};
  getJSON("/poeitems/schema/items").done(function(obj) {
    return window.items = items = obj;
  });
  getJSON("/poeitems/schema/mod_name_lookup").done(function(obj) {
    window.modNameLookup = modNameLookup = obj;
    return getJSON("/poeitems/schema/mods").done(function(obj) {
      var mod, modsLookup, _hybridValues, _i, _len;

      _hybridValues = function(mod) {
        var matches, type, _;

        if (!modNameLookup.hybrids[mod.description]) {
          return;
        }
        type = mod.description;
        delete mod.min_value;
        delete mod.max_value;
        if (type === "Light Radius / +Accuracy Rating") {
          matches = mod.value.match(/([0-9]+) \/ ([0-9]+) to ([0-9]+)/i);
          if (matches) {
            _ = matches[0], mod.value_one = matches[1], mod.value_min_two = matches[2], mod.value_max_two = matches[3];
          }
        } else {
          matches = mod.value.match(/([0-9]+) to ([0-9]+) \/ ([0-9]+) to ([0-9]+)/i);
          if (matches) {
            _ = matches[0], mod.value_min_one = matches[1], mod.value_max_one = matches[2], mod.value_min_two = matches[3], mod.value_max_two = matches[4];
          }
        }
        if (!matches) {
          return console.log("ERROR: Failed match after json load for", mod);
        }
      };
      for (_i = 0, _len = obj.length; _i < _len; _i++) {
        mod = obj[_i];
        _hybridValues(mod);
      }
      return window.modsLookup = modsLookup = obj;
    });
  });
  Items = (function(_super) {
    __extends(Items, _super);

    function Items() {
      _ref = Items.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Items.prototype.model = Item;

    return Items;

  })(Backbone.Collection);
  Item = (function(_super) {
    __extends(Item, _super);

    function Item() {
      _ref1 = Item.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    Item.prototype.defaults = function() {
      return {
        prefixes: 0,
        suffixes: 0
      };
    };

    Item.prototype.computeExplicitMods = function() {
      var affinities, allPossibleRollsForThisItem, itemLevel, string, type, _decideModRoll, _i, _len, _processSingleMod, _ref2,
        _this = this;

      console.log("In the model", this.toJSON());
      /*
      1. Loop through each mod.
      2. Find out what number variation is in use.
      3. Store numbers and replace them in string with #
      4. Find all matching mods via mod_name_lookup.json file (modNameLookup)
      5. Return possible mods for that item via item type and level against mods.json (itemTypeLookup)
      6. Limit mods to those mods existing in both lists (modNameLookup + itemTypeLookup = modList)
      7. If mods are found for more than one string it means a hybrid has been rolled (treat number comparison differently)
      8. Find out what level each mod rolled by looking at numbers and modList
      9. Give each roll a score (actual roll / possible roll)
      */

      type = this.get('type');
      itemLevel = this.get('item_level');
      affinities = this.get('affinities');
      allPossibleRollsForThisItem = modsLookup.filter(function(x) {
        var _ref2;

        return x.level <= itemLevel && (_ref2 = x[type], __indexOf.call(affinities, _ref2) >= 0);
      });
      _processSingleMod = function(string) {
        var mod, _, _ref2, _ref3, _ref4, _ref5, _ref6;

        mod = {
          orig: string,
          finalized: false
        };
        /*
        # Mod Variations
        1-2         [min]-[max]
        +11%        +[num]%
        +125        +[num]
        43%         [num]%
        4.8         [num]
        */

        if (/[1-9]+-[1-9]+/i.test(string)) {
          _ref2 = string.match(/([1-9]+)-([1-9]+)/i), _ = _ref2[0], mod.min_value = _ref2[1], mod.max_value = _ref2[2];
          mod.type = '#-#';
        } else if (/\+[1-9]+%/i.test(string)) {
          _ref3 = string.match(/\+([1-9]+)%/i), _ = _ref3[0], mod.value = _ref3[1];
          mod.type = '+#%';
        } else if (/\+[1-9]+/i.test(string)) {
          _ref4 = string.match(/\+([1-9]+)/i), _ = _ref4[0], mod.value = _ref4[1];
          mod.type = '+#';
        } else if (/[1-9]+%/i.test(string)) {
          _ref5 = string.match(/([1-9]+)%/i), _ = _ref5[0], mod.value = _ref5[1];
          mod.type = '#%';
        } else if (/[1-9]+/i.test(string)) {
          _ref6 = string.match(/([1-9]+)/i), _ = _ref6[0], mod.value = _ref6[1];
          mod.type = '#';
        }
        mod.str = string.toLowerCase().replace(/[1-9]+/i, '#');
        mod.nameLookup = modNameLookup.lookup[mod.str] ? modNameLookup.lookup[mod.str] : "Unknown";
        return mod;
      };
      mods = [];
      _ref2 = this.get('explicit');
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        string = _ref2[_i];
        mods.push(_processSingleMod(string));
      }
      _decideModRoll = function(mod) {
        var hybrid, possibleRolls, val, _compareNameLookupWithOtherMods, _j, _len1, _ref3;

        if (__indexOf.call(mod.nameLookup, "Base Stun Recovery +%") >= 0) {
          mod.finalized = true;
        }
        if (mod.finalized) {
          return mod;
        }
        mod.roll = {};
        possibleRolls = allPossibleRollsForThisItem.filter(function(x) {
          var _ref3, _ref4;

          return (_ref3 = x.description, __indexOf.call(mod.nameLookup, _ref3) >= 0) && x.level <= itemLevel && (_ref4 = x[type], __indexOf.call(affinities, _ref4) >= 0);
        });
        val = parseInt(mod.value);
        if (mod.nameLookup.length === 1) {
          mod.roll = (possibleRolls.filter(function(x) {
            return x.min_value <= val && x.max_value >= val;
          }))[0];
          mod.higher_rolls = possibleRolls.filter(function(x) {
            return x.max_value > val;
          });
          mod.lower_rolls = possibleRolls.filter(function(x) {
            return x.max_value < val;
          });
        } else {
          hybrid = {};
          _compareNameLookupWithOtherMods = function(string) {
            var possibleHybridRolls;

            if (string === "Local Armour And Energy Shield +% / Base Stun Recovery +%") {
              hybrid = (mods.filter(function(x) {
                return __indexOf.call(x.nameLookup, "Base Stun Recovery +%") >= 0;
              }))[0];
            }
            if (!hybrid) {
              return;
            }
            /*
            The second value is always considered the "hybrid" and will
            always be run via processing the first roll.
            
            All hybrids run this accept the Light Radius one
              value_min_one: "42"
              value_max_one: "50"
            
              value_min_two: "14"
              value_max_two: "15"
            */

            hybrid.finalized = true;
            possibleHybridRolls = allPossibleRollsForThisItem.filter(function(x) {
              var _ref3;

              return x.description === string && x.level <= itemLevel && (_ref3 = x[type], __indexOf.call(affinities, _ref3) >= 0);
            });
            hybrid.roll = (possibleHybridRolls.filter(function(x) {
              return x.value_min_two <= hybrid.value && x.value_max_two >= hybrid.value;
            }))[0];
            hybrid.higher_rolls = possibleRolls.filter(function(x) {
              return x.value_max_two > val;
            });
            hybrid.lower_rolls = possibleRolls.filter(function(x) {
              return x.value_max_two < val;
            });
            if (hybrid.roll) {
              return mod.hybrid = hybrid;
            }
          };
          _ref3 = mod.nameLookup;
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            string = _ref3[_j];
            _compareNameLookupWithOtherMods(string);
          }
        }
        if (!mod.roll) {

        } else {
          if (mod.roll.prefix_suffix === "Suffix") {
            return _this.set({
              'suffixes': _this.get('suffixes') + 1
            });
          } else {
            return _this.set({
              'prefixes': _this.get('prefixes') + 1
            });
          }
        }
      };
      _decideModRoll(mods[0]);
      _decideModRoll(mods[1]);
      _decideModRoll(mods[2]);
      _decideModRoll(mods[3]);
      _decideModRoll(mods[4]);
      this.set({
        'mods': mods
      });
      return console.log("Item", this.toJSON());
    };

    return Item;

  })(Backbone.Model);
  PasteBinView = (function(_super) {
    __extends(PasteBinView, _super);

    function PasteBinView() {
      _ref2 = PasteBinView.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    PasteBinView.prototype.model = Item;

    PasteBinView.prototype.el = '#pasteBinSection';

    PasteBinView.prototype.template = $('#paste-bin-section-tmpl');

    PasteBinView.prototype.mod_template = $('#roll-item-mod-tmpl');

    PasteBinView.prototype.events = {
      'click #rollItemButton': '_eventRollItem'
    };

    PasteBinView.prototype.initialize = function() {
      this.render();
      return this;
    };

    PasteBinView.prototype.render = function() {
      return $(this.el).append(_.template(this.template.html()));
    };

    PasteBinView.prototype.renderMods = function() {
      return $('#roll_mod_holder', this.el).html(_.template(this.mod_template.html(), {
        model: this.model.toJSON()
      }));
    };

    PasteBinView.prototype._eventRollItem = function(e) {
      e && e.preventDefault;
      return this.rollItem($('#pasteHolder').val());
    };

    PasteBinView.prototype.rollItem = function(item) {
      var section, sections, _i, _len;

      if (!item) {
        return false;
      }
      item = item.replace("You cannot use this item. Its stats will be ignored. Please remove it.\n--------", "");
      sections = item.split('--------').reverse();
      this.model = new Item();
      for (_i = 0, _len = sections.length; _i < _len; _i++) {
        section = sections[_i];
        this.processRawSection(_i + 1, section.split('\n'));
      }
      this.model.computeExplicitMods();
      processedItems.add(this.model);
      return this.renderMods();
    };

    PasteBinView.prototype.processRawSection = function(count, rawSection) {
      var affinities, armour, cleanType, energy_shield, evasion, foundItem, identify, identity, level, name, pretty_type, rarity, req_dex, req_int, req_str, section, string, type, _i, _len;

      section = rawSection.filter(function(x) {
        return x.trim() !== "";
      });
      identity = count !== 1 ? false : "explicit";
      identify = function(string) {
        if (identity) {
          return false;
        }
        if (/rarity:/i.test(string)) {
          return identity = "item_type";
        } else if (/requirements/i.test(string)) {
          return identity = "requirements";
        } else if (/itemlevel/i.test(string)) {
          return identity = "item_level";
        } else if (/sockets/i.test(string)) {
          return identity = "sockets";
        } else if (/quality|augmented/i.test(string)) {
          return identity = "implicit";
        }
      };
      for (_i = 0, _len = section.length; _i < _len; _i++) {
        string = section[_i];
        identify(string);
      }
      switch (identity) {
        case "explicit":
          return this.model.set({
            'explicit': section
          });
        case "item_type":
          if (section[0]) {
            rarity = section[0].toLowerCase().replace("rarity:", "").trim();
          }
          if (section[1]) {
            name = section[1];
          }
          if (section[2]) {
            pretty_type = section[2];
            cleanType = section[2].toLowerCase().replace("'", "");
            if (items[cleanType]) {
              foundItem = items[cleanType];
              type = foundItem.type;
              level = foundItem.level;
              armour = foundItem.armour;
              evasion = foundItem.evasion;
              energy_shield = foundItem.energy_shield;
              req_str = foundItem.req_str ? parseInt(foundItem.req_str) : 0;
              req_dex = foundItem.req_dex ? parseInt(foundItem.req_dex) : 0;
              req_int = foundItem.req_int ? parseInt(foundItem.req_int) : 0;
              affinities = ['Yes'];
              switch (false) {
                case !(req_str > 0 && !req_dex && !req_int):
                  affinities.push('Yes (str)');
                  affinities.push('Yes (str-only)');
                  break;
                case !(!req_str && req_dex > 0 && !req_int):
                  affinities.push('Yes (dex)');
                  affinities.push('Yes (dex-only)');
                  break;
                case !(!req_str && !req_dex && req_int > 0):
                  affinities.push('Yes (int)');
                  affinities.push('Yes (int-only)');
                  break;
                case !(req_str > 0 && req_dex > 0 && !req_int):
                  affinities.push('Yes (str)');
                  affinities.push('Yes (dex)');
                  affinities.push('Yes (dex-str)');
                  break;
                case !(req_str > 0 && !req_dex && req_int > 0):
                  affinities.push('Yes (str)');
                  affinities.push('Yes (int)');
                  affinities.push('Yes (int-str)');
                  break;
                case !(!req_str && req_dex > 0 && req_int > 0):
                  affinities.push('Yes (dex)');
                  affinities.push('Yes (int)');
                  affinities.push('Yes (int-dex)');
              }
            }
          }
          return this.model.set({
            "rarity": rarity ? rarity : null,
            "name": name ? name : null,
            "pretty_type": pretty_type ? pretty_type : null,
            "type": type ? type : null,
            "level": level ? level : null,
            "armour": armour ? armour : null,
            "evasion": evasion ? evasion : null,
            "energy_shield": energy_shield ? energy_shield : null,
            "req_str": req_str ? req_str : null,
            "req_dex": req_dex ? req_dex : null,
            "req_int": req_int ? req_int : null,
            "affinities": affinities
          });
        case "requirements":
          return this.model.set({
            "requirements": section
          });
        case "item_level":
          return this.model.set({
            "item_level": section[0].toLowerCase().replace("itemlevel:", "").trim()
          });
        case "sockets":
          return this.model.set({
            "sockets": section[0].toLowerCase().replace("sockets:", "").trim()
          });
        case "implicit":
          return this.model.set({
            "implicit": section
          });
      }
    };

    return PasteBinView;

  })(Backbone.View);
  processedItems = new Items;
  return pasteBinView = new PasteBinView;
});
